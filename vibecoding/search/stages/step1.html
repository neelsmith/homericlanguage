<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Iliad Scansion Search</title>
  <style>
    body {
      font-family: sans-serif;
      line-height: 1.5;
      margin: 2em;
      background-color: #f8f8f8;
    }
    input[type="text"] {
      width: 300px;
    }
    .result {
      margin-bottom: 1em;
      background: white;
      padding: 1em;
      border: 1px solid #ccc;
    }
    .pagination {
      margin-top: 1em;
    }
    button {
      margin: 0 2px;
    }
  </style>
</head>
<body>
  <h2>Iliad Scansion Search</h2>
  <p>Type a (unaccented) Greek string to find matching passages:</p>
  <input type="text" id="searchInput" placeholder="Enter Greek text">
  <button onclick="performSearch()">Search</button>

  <div id="results"></div>
  <div class="pagination" id="pagination"></div>

  <script>
    const DATA_URL = 'https://raw.githubusercontent.com/neelsmith/homericlanguage/refs/heads/main/scansion-expanded.cex';

    // Corpus map: Passage ID => { accentedText: "...", plainText: "..." }
    const corpus = new Map();

    // For pagination
    let currentResults = [];
    const pageSize = 10;
    let currentPage = 1;

    async function loadData() {
      const response = await fetch(DATA_URL);
      const text = await response.text();
      const lines = text.split('\n').filter(l => l.trim() !== '');
      const header = lines.shift();
      const headerCols = header.split('|');

      // Indices based on header
      const idx = {};
      headerCols.forEach((col, i) => idx[col.trim()] = i);

      let prevPassage = null;
      let prevToken = null;
      let currentOutput = '';
      let currentPlain = '';

      for (const line of lines) {
        const parts = line.split('|');
        const passage = parts[idx['Passage']];
        const syllText = parts[idx['SyllableText']];
        const token = parts[idx['Token']];

        if (passage !== prevPassage) {
          // Commit old one
          if (prevPassage !== null) {
            corpus.set(prevPassage, {
              accentedText: currentOutput.trim(),
              plainText: stripAccents(currentOutput)
            });
          }
          // Reset
          currentOutput = syllText;
        } else {
          if (token !== prevToken) {
            currentOutput += ' ' + syllText;
          } else {
            currentOutput += syllText;
          }
        }

        prevPassage = passage;
        prevToken = token;
      }

      // Add final passage
      if (prevPassage !== null && !corpus.has(prevPassage)) {
        corpus.set(prevPassage, {
          accentedText: currentOutput.trim(),
          plainText: stripAccents(currentOutput)
        });
      }

      console.log(`Loaded ${corpus.size} unique passages`);
    }

    function stripAccents(text) {
      // Remove Greek accents and breathings
      // Based on Unicode Greek diacritics:
      // tonos, oxia, varia, psili, dasia, perispomeni, etc.
      return text
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")  // Strip accents
        .replace(/[ͺ·—]/g, "")           // Strip punctuation if needed
        .replace(/\s+/g, ' ')            // Normalize spaces
        .trim()
        .toLowerCase();                  // Normalize case
    }

    function performSearch() {
      const search = document.getElementById('searchInput').value.trim().toLowerCase();
      if (search === '') return;

      currentResults = [];
      currentPage = 1;

      for (const [passage, data] of corpus.entries()) {
        if (data.plainText.includes(search)) {
          currentResults.push({ passage, text: data.accentedText });
        }
      }

      renderResults();
    }

    function renderResults() {
      const resultsDiv = document.getElementById('results');
      const paginationDiv = document.getElementById('pagination');
      resultsDiv.innerHTML = '';
      paginationDiv.innerHTML = '';

      if (currentResults.length === 0) {
        resultsDiv.innerHTML = '<p>No results found.</p>';
        return;
      }

      const totalPages = Math.ceil(currentResults.length / pageSize);
      const startIdx = (currentPage - 1) * pageSize;
      const endIdx = Math.min(currentResults.length, startIdx + pageSize);

      for (let i = startIdx; i < endIdx; i++) {
        const result = currentResults[i];
        const div = document.createElement('div');
        div.className = 'result';
        div.innerHTML = `<strong>${result.passage}</strong><br><span style="font-family: 'Palatino Linotype', 'Georgia', serif; font-size: 1.2em;">${result.text}</span>`;
        resultsDiv.appendChild(div);
      }

      // Pagination controls
      const prevBtn = document.createElement('button');
      prevBtn.textContent = 'Previous';
      prevBtn.disabled = currentPage === 1;
      prevBtn.onclick = () => {
        if (currentPage > 1) {
          currentPage--;
          renderResults();
        }
      };

      const nextBtn = document.createElement('button');
      nextBtn.textContent = 'Next';
      nextBtn.disabled = currentPage === totalPages;
      nextBtn.onclick = () => {
        if (currentPage < totalPages) {
          currentPage++;
          renderResults();
        }
      };

      paginationDiv.appendChild(prevBtn);
      paginationDiv.append(` Page ${currentPage} of ${totalPages} `);
      paginationDiv.appendChild(nextBtn);
    }

    // Load data on page load
    loadData();
  </script>
</body>
</html>